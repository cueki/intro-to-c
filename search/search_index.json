{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro to C Final (ch 7+)","text":""},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Standard Library Functions - The built-in functions</li> <li>Core Concepts - Fundies</li> <li>Practice Problems - Exercises and problem types</li> <li>Common Patterns - Code patterns and algorithms</li> </ul>"},{"location":"#about-this-guide","title":"About This Guide","text":"<ul> <li>Class 08: Functions</li> <li>Class 09: Pointers </li> <li>Class 10: Character Handling &amp; String Processing</li> <li>Class 11: String Manipulation</li> </ul>"},{"location":"concepts/","title":"Core Programming Concepts","text":""},{"location":"concepts/#functions","title":"Functions","text":"<ul> <li>Function prototypes and definitions</li> <li>Parameter passing by value vs by reference</li> <li>Return values and types</li> <li>Simple mult function: <code>int square(int number) { return number * number; }</code></li> </ul>"},{"location":"concepts/#pointers","title":"Pointers","text":"<p>Critical concepts: - Pointer declaration: <code>int *ptr</code></p> <ul> <li> <p>Address-of operator: <code>&amp;variable</code></p> </li> <li> <p>Dereference operator: <code>*ptr</code></p> </li> <li> <p>Pointer arithmetic: <code>ptr+1</code>, <code>ptr++</code>, <code>ptr--</code></p> </li> <li> <p>Array-pointer relationship: <code>myArray \u2261 &amp;myArray[0]</code></p> </li> <li> <p>Pointer to pointer: <code>int **ptrToPtr</code></p> </li> <li> <p>Function parameter passing with pointers</p> </li> </ul> <p>Key relationships:</p> <ul> <li> <p><code>arr[i] \u2261 *(arr+i)</code></p> </li> <li> <p><code>&amp;arr[i] \u2261 arr+i</code></p> </li> <li> <p>Arrays passed to functions become pointers</p> </li> </ul>"},{"location":"concepts/#arrays-and-strings","title":"Arrays and Strings","text":"<ul> <li>Arrays as function parameters (passed as pointers)</li> <li>Pointer arithmetic with arrays</li> <li>Boundary checking and memory management</li> <li>Null terminator (<code>\\0</code>) handling in strings</li> <li>String indexing vs pointer notation</li> </ul>"},{"location":"concepts/#dynamic-memory-allocation","title":"Dynamic Memory Allocation","text":"<ul> <li><code>malloc()</code> and <code>free()</code></li> <li>Error checking for allocation failures (Don't forget...)</li> </ul> <p>Dynamic string allocation based on input length is a good usecase for this.</p>"},{"location":"concepts/#stack-data-structure","title":"Stack Data Structure","text":"<ul> <li>Using arrays to implement stack behavior</li> <li>Push operation: <code>stack[stackPos++] = value</code></li> <li>Pop operation: <code>value = stack[--stackPos]</code></li> <li>Stack empty check: <code>stackPos &lt;= 0</code></li> </ul>"},{"location":"concepts/#key-topics-by-class","title":"Key Topics by Class","text":""},{"location":"concepts/#class-08-functions","title":"Class 08 - Functions","text":"<ul> <li>Basic function structure and prototypes</li> <li>Function calls and return values</li> <li>Parameter passing mechanisms</li> </ul>"},{"location":"concepts/#class-09-pointers","title":"Class 09 - Pointers","text":"<ul> <li>Memory addresses and pointer arithmetic</li> <li>Predicting memory addresses and values</li> <li>Array-pointer relationships</li> <li>Function parameter passing with pointers</li> <li>Understanding output from pointer exercises</li> </ul>"},{"location":"concepts/#class-10-character-handling-string-processing","title":"Class 10 - Character Handling &amp; String Processing","text":"<ul> <li>Character classification functions (<code>ctype.h</code>)</li> <li>String length calculations (manual vs <code>strlen</code>)</li> <li>Advanced string comparison logic</li> <li>Character conversion functions</li> </ul>"},{"location":"concepts/#class-11-string-manipulation","title":"Class 11 - String Manipulation","text":"<p>Functions to implement:</p> <ul> <li> <p><code>stringCopy1/2()</code> - copying strings with arrays vs pointers</p> </li> <li> <p><code>stringNCopy1/2()</code> - copying n characters</p> </li> <li> <p><code>stringCat1/2()</code> - string concatenation  </p> </li> <li> <p><code>stringNCat1/2()</code> - concatenating n characters</p> </li> <li> <p>String comparison using <code>strncmp()</code> with shortest length</p> </li> </ul>"},{"location":"functions/","title":"Standard Library Functions","text":""},{"location":"functions/#inputoutput-functions-stdioh","title":"Input/Output Functions (<code>stdio.h</code>)","text":"<p><code>printf(format, ...)</code> - Formatted output to stdout</p> <ul> <li>Format specifiers: <code>%d</code> (int), <code>%p</code> (pointer), <code>%s</code> (string), <code>%zu</code> (size_t)</li> </ul> <p><code>scanf(format, ...)</code> - Formatted input from stdin</p> <ul> <li><code>scanf(\"%s\", string)</code> - read string</li> <li><code>scanf(\"%80[^\\n]\", buffer)</code> - read up to 80 chars, stop at newline</li> </ul> <p><code>puts(string)</code> - Output string + newline to stdout</p> <p><code>getchar()</code> - Read single character from stdin</p>"},{"location":"functions/#memory-management-functions-stdlibh","title":"Memory Management Functions (<code>stdlib.h</code>)","text":"<p><code>malloc(size_t size)</code> - Allocate dynamic memory</p> <ul> <li>Returns <code>void*</code> pointer or <code>NULL</code> if failed</li> <li>Example: <code>char* ptr = malloc(sizeof(char) * (len + 1))</code></li> </ul> <p><code>free(void* ptr)</code> - Deallocate dynamic memory</p> <ul> <li>Must pair with every <code>malloc()</code></li> </ul> <p><code>srand(unsigned int seed)</code> - Seed random number generator</p> <ul> <li>Common: <code>srand((unsigned int)time(NULL))</code></li> </ul> <p><code>rand()</code> - Generate random integer 0 to RAND_MAX</p> <ul> <li><code>rand() % 10 + 1</code> gives range 1-10</li> </ul> <p><code>system(command)</code> - Execute system command</p> <ul> <li><code>system(\"pause\")</code> - Use <code>getchar()</code> instead</li> </ul>"},{"location":"functions/#string-functions-stringh","title":"String Functions (<code>string.h</code>)","text":"<p><code>strlen(const char* str)</code> - Get string length (excluding <code>\\0</code>)</p> <ul> <li>Returns <code>size_t</code></li> </ul> <p><code>strcpy(char* dest, const char* src)</code> - Copy entire string</p> <ul> <li>Includes <code>\\0</code> terminator</li> </ul> <p><code>strncmp(const char* s1, const char* s2, size_t n)</code> - Compare n characters</p> <ul> <li>Returns: <code>&lt;0</code> (s10 (equal), <code>&gt;0</code> (s1&gt;s2)"},{"location":"functions/#character-classification-functions-ctypeh","title":"Character Classification Functions (<code>ctype.h</code>)","text":"<ul> <li><code>isdigit(c)</code> - Check if character is digit (0-9)</li> <li><code>isalpha(c)</code> - Check if character is alphabetic (a-z, A-Z)</li> <li><code>isalnum(c)</code> - Check if character is alphanumeric</li> <li><code>isxdigit(c)</code> - Check if character is hexadecimal digit</li> <li><code>islower(c)</code> - Check if character is lowercase</li> <li><code>isupper(c)</code> - Check if character is uppercase</li> <li><code>isspace(c)</code> - Check if character is whitespace</li> <li><code>iscntrl(c)</code> - Check if character is control character</li> <li><code>ispunct(c)</code> - Check if character is punctuation</li> <li><code>isprint(c)</code> - Check if character is printable</li> <li><code>isgraph(c)</code> - Check if character is graphic (printable, not space)</li> </ul>"},{"location":"functions/#character-conversion-functions-ctypeh","title":"Character Conversion Functions (<code>ctype.h</code>)","text":"<ul> <li><code>tolower(c)</code> - Convert character to lowercase</li> <li><code>toupper(c)</code> - Convert character to uppercase</li> </ul>"},{"location":"functions/#time-functions-timeh","title":"Time Functions (<code>time.h</code>)","text":"<p><code>time(time_t* timer)</code> - Get current time</p> <ul> <li>Used for seeding: <code>time(NULL)</code></li> </ul>"},{"location":"patterns/","title":"Common Patterns and Algorithms","text":""},{"location":"patterns/#pointer-patterns","title":"Pointer Patterns","text":""},{"location":"patterns/#basic-pointer-declaration-and-usage","title":"Basic Pointer Declaration and Usage","text":"<pre><code>int value = 42;\nint *ptr = &amp;value;      // Point to value\nprintf(\"%d\", *ptr);     // Dereference to get 42\n*ptr = 100;             // Modify value through pointer\n</code></pre>"},{"location":"patterns/#pointer-arithmetic-with-arrays","title":"Pointer Arithmetic with Arrays","text":"<pre><code>int arr[5] = {10, 20, 30, 40, 50};\nint *ptr = arr;         // Same as ptr = &amp;arr[0]\n\n// These are equivalent:\narr[2] == *(arr + 2) == *(ptr + 2) == ptr[2]\n\n// Moving through array:\nptr++;                  // Now points to arr[1]\nptr += 2;               // Now points to arr[3]\n</code></pre>"},{"location":"patterns/#function-parameter-passing-with-pointers","title":"Function Parameter Passing with Pointers","text":"<pre><code>// Modify original variable\nvoid increment(int *num) {\n    (*num)++;           // Increment the value at address\n}\n\n// Pass array to function\nvoid printArray(int *arr, int size) {\n    for (int i = 0; i &lt; size; i++) {\n        printf(\"%d \", arr[i]);    // or *(arr + i)\n    }\n}\n</code></pre>"},{"location":"patterns/#pointer-to-pointer-pattern","title":"Pointer to Pointer Pattern","text":"<pre><code>int value = 42;\nint *ptr = &amp;value;\nint **ptrToPtr = &amp;ptr;\n\n// Accessing value through double pointer:\nprintf(\"%d\", **ptrToPtr);    // Prints 42\n</code></pre>"},{"location":"patterns/#dynamic-array-allocation-pattern","title":"Dynamic Array Allocation Pattern","text":"<pre><code>int size = 10;\nint *dynamicArray = malloc(sizeof(int) * size);\nif (dynamicArray == NULL) {\n    // Handle allocation failure\n    return -1;\n}\n\n// Use the array\nfor (int i = 0; i &lt; size; i++) {\n    dynamicArray[i] = i * 2;\n}\n\n// Don't forget to free\nfree(dynamicArray);\ndynamicArray = NULL;    // Good practice\n</code></pre>"},{"location":"patterns/#pointer-arithmetic-memory-address-calculation","title":"Pointer Arithmetic Memory Address Calculation","text":"<pre><code>int arr[4] = {10, 20, 30, 40};\nint *ptr = arr;\n\n// If arr starts at address 0x1000:\n// ptr + 0 \u2192 0x1000 (points to arr[0])\n// ptr + 1 \u2192 0x1004 (points to arr[1]) \n// ptr + 2 \u2192 0x1008 (points to arr[2])\n// ptr + 3 \u2192 0x100C (points to arr[3])\n\n// Distance between pointers:\nint *ptr1 = &amp;arr[1];\nint *ptr2 = &amp;arr[3];\nint distance = ptr2 - ptr1;  // Result: 2 (not 8 bytes!)\n</code></pre>"},{"location":"patterns/#string-processing-with-pointers","title":"String Processing with Pointers","text":"<pre><code>// Count characters using pointer\nint countChars(const char *str) {\n    int count = 0;\n    while (*str != '\\0') {\n        count++;\n        str++;              // Move to next character\n    }\n    return count;\n}\n\n// Copy string using pointers\nvoid stringCopy(char *dest, const char *src) {\n    while (*src != '\\0') {\n        *dest = *src;\n        dest++;\n        src++;\n    }\n    *dest = '\\0';           // Don't forget null terminator\n}\n</code></pre>"},{"location":"patterns/#string-length-calculation","title":"String Length Calculation","text":"<p>Method 1 (while loop): <pre><code>size_t count = 0;\nwhile (*ptr != '\\0') {\n  ++count;\n  ++ptr;\n}\nreturn count;\n</code></pre></p> <p>Method 2 (for loop): <pre><code>size_t count = 0;\nfor (; *ptr != '\\0'; ++ptr, ++count);\nreturn count;\n</code></pre></p>"},{"location":"patterns/#string-comparison-pattern","title":"String Comparison Pattern","text":"<pre><code>len1 = strlen(string1);\nlen2 = strlen(string2);\ncompareLen = (len1 &lt; len2) ? len1 : len2;\nresult = strncmp(string1, string2, compareLen);\n</code></pre>"},{"location":"patterns/#dynamic-memory-allocation-pattern","title":"Dynamic Memory Allocation Pattern","text":"<pre><code>char* ptr = malloc(sizeof(char) * (length + 1));\nif (ptr == NULL) {\n  // Handle error\n  return NULL;\n}\n// Use the memory\nstrcpy(ptr, source);\n// Remember to free(ptr) when done\n</code></pre>"},{"location":"patterns/#stack-implementation-pattern","title":"Stack Implementation Pattern","text":"<pre><code>char* stack = malloc(strlen(input));\nint stackPos = 0;\n\n// Push: stack[stackPos++] = item;\n// Pop: item = stack[--stackPos];\n// Empty check: stackPos &lt;= 0\n\nfree(stack);\n</code></pre>"},{"location":"patterns/#boundary-checking-pattern","title":"Boundary Checking Pattern","text":"<pre><code>if (position &lt; 1) {\n  position = 1;\n}\nif (position &gt; MAX_POSITION) {\n  position = MAX_POSITION;\n}\n</code></pre>"},{"location":"practice/","title":"Practice Problems/Labs Overview","text":""},{"location":"practice/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<ul> <li>Calculate memory addresses manually</li> <li>Understand 4-byte integer spacing</li> <li>Predict pointer increment/decrement results</li> <li>Function parameter passing effects</li> </ul>"},{"location":"practice/#tortoise-and-hare-race-simulation","title":"Tortoise and Hare Race Simulation","text":"<ul> <li>Random number generation with <code>srand()</code> and <code>rand()</code></li> <li>Switch statements for movement logic:</li> <li>Tortoise: Cases 1-5: FAST_PLOD (+3), Cases 6-7: SLIP (-6), Cases 8-10: SLOW_PLOD (+1)</li> <li>Hare: Cases 1-2: SLEEP (0), Case 3-4: BIG_HOP (+9), Case 5: BIG_SLIP (-12), Cases 6-8: SMALL_HOP (+1), Cases 9-10: SMALL_SLIP (-2)</li> <li>Boundary checking and race conditions</li> <li>Position tracking and winner determination</li> </ul>"},{"location":"practice/#string-function-implementations","title":"String Function Implementations","text":"<ul> <li>Complete missing string functions using both array and pointer methods</li> <li>Proper null terminator handling</li> <li>Return pointer to modified string</li> </ul>"},{"location":"practice/#memory-management-exercises","title":"Memory Management Exercises","text":"<ul> <li>Dynamic string allocation (<code>get_string</code> function)</li> <li>Proper <code>malloc</code>/<code>free</code> usage</li> <li>Error checking for allocation failures</li> </ul>"},{"location":"practice/#bracket-validation","title":"Bracket Validation","text":"<ul> <li>Stack-based matching algorithm</li> <li>Handling multiple bracket types: <code>()</code>, <code>{}</code>, <code>[]</code></li> <li>Proper memory cleanup on all exit paths</li> </ul>"},{"location":"practice/#array-intersection","title":"Array Intersection","text":"<ul> <li>Counting sort algorithm implementation</li> <li>O(n) vs O(n\u00b2) complexity considerations</li> <li>Memory vs speed optimization tradeoffs</li> </ul>"}]}